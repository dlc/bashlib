#!/usr/bash

# $Id$
# Author:     darren chamberlain <dlc@users.sourceforge.net>
# Co-Author:  Paul Bournival <paulb-ns@cajun.nu>
#
# bashlib is used by sourcing it at the beginning of scripts that
# needs its functionality (by using the `.' or `source' commands).

# Requires the following standard GNU utilities:
_awk=/usr/bin/awk
_bc=/usr/bin/bc
_cat=/usr/bin/cat
_cut=/bin/cut
_date=/bin/date
_echo=/bin/echo
_egrep=/usr/bin/egrep
_env=/usr/bin/env
_grep=/usr/bin/grep
_printf=/usr/bin/printf
_sed=/usr/bin/sed
_tr=/usr/bin/tr

# You should be sure that they are all pointing to the correct places
# I should have a configure script that does all this stuff.

#
# Set version number
#
VERSION=$(${_echo} '$Revision$' | ${_awk} '{print $2}')

# -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
# Initialization stuff begins here. These things run immediately, and
# do the parameter/cookie parsing.
#
# -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

# Global debug flag. Set to 0 to disable debugging throughout the lib
DEBUG=0

# capture stdin for POST methods. POST requests don't always come in
# with a newline attached, so we use cat to grab stdin and append a newline.
# This is a wonderful hack, and thanks to paulb.
STDIN=$(${_cat})
if [ -n "${STDIN}" ]; then
  QUERY_STRING="${STDIN}&${QUERY_STRING}"
fi

# Handle GET and POST requests... (the QUERY_STRING will be set)
if [ -n "${QUERY_STRING}" ]; then 
  for Q in $(${_echo} ${QUERY_STRING} | ${_tr} "&" "\012") ; do
    # get the name of the key, and decode it
    key=${Q%%=*}
    key=$(${_echo} ${key} | ${_sed} -e 's/%\(\)/\\\x/g' | ${_tr} "+" " ")
    key=$(${_printf} ${key})

    # get the value and decode it
    value=${Q##*=}
    value=$(${_echo} ${value} | ${_sed} -e 's/%\(\)/\\\x/g' | ${_tr} "+" " ")
    value=$(${_printf} ${value})

    eval "export FORM_${key}='${value}'"
  done
fi

# this section works identically to the query string parsing code,
# with the (obvious) exception that variables are stuck into the
# environment with the prefix COOKIE_ rather than FORM_. This is to
# help distinguish them from the other variables that get set
# automatically.
if [ -n "${HTTP_COOKIE}" ]; then 
  for Q in $(${_echo} ${HTTP_COOKIE} | ${_sed} -e 's/; / /g'); do
    # Strip trailing ; off the value
    Q=$(${_echo} ${Q} | ${_sed} -e 's/;$//')

    # get the name of the key, and decode it
    name=${Q%%=*}
    name=$(${_echo} ${name} | ${_sed} -e 's/%\(\)/\\\x/g' | ${_tr} "+" " ")
    name=$(${_echo} ${name} | ${_tr} -d ".-")
    name=$(${_printf} ${name})

    # get the value and decode it
    value=${Q##*=}
    value=$(${_echo} ${value} | ${_sed} -e 's/%\(\)/\\\x/g' | ${_tr} "+" " ")
    value=$(${_printf} ${value})

    eval "export COOKIE_${name}='${value}'"
  done
fi
